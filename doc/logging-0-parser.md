# Log Parser 구성 (v1) — 시스템 적용판

본 문서는 **사용자 정의 파서 JSON(v1)**의 구조와 동작, 그리고 EdgeTool이 워크스페이스에서 해당 파일을 생성/유지/이동하는 정책을 **현재 시스템 구현(보수 적용, `memory_mode_threshold` 반영, 무효 라인 드롭 적용)** 기준으로 설명합니다.

---

## 파일 위치

- **워크스페이스 루트**: `<workspace>/`
- **파서 설정(실제 사용 파일)**: `<workspace>/.config/custom_log_parser.json`
- **내장 템플릿(JSON)**: `media/resources/custom_log_parser.template.v1.json`
- **내장 README 템플릿**: `doc/logging-0-parser.md`

> 확장이 활성화되면 현재 워크스페이스에 `.config/custom_log_parser.json`이 없을 경우 템플릿으로 자동 생성됩니다.  
> 명령/버튼 **“Parser 초기화”**를 실행하면 기존 내용을 덮어쓰고 템플릿으로 재생성합니다. (README도 함께 재생성)

---

## 워크스페이스 이동/교체 시 정책

작업폴더를 변경했는데 새 워크스페이스에 `.config/`가 없으면:

1) **이전 워크스페이스의 `.config` 폴더를 통째로 복사**합니다.  
2) 새 워크스페이스에 `.config`가 이미 있으면 **복사를 생략**합니다.  
3) 이전 워크스페이스에 `.config`가 없으면 **템플릿으로 시드**합니다.  
4) 이전 워크스페이스의 `.config` 폴더는 도구가 **정리(삭제)**합니다.  

이 로직은 내부 모듈 **`parserConfigSeeder`** 가 담당합니다.

---

## JSON 스키마 (v1)

> 아래 스키마는 **현재 구현과 일치**합니다. (단일 `line_regex` 나 `time_parse` 키는 지원하지 않습니다.)

```jsonc
{
  "version": 1,
  "requirements": {
    "fields": {
      "time": true,
      "process": true,
      "pid": false,
      "message": true
    }
  },
  "preflight": {
    "sample_lines": 200,
    "min_match_ratio": 0.8,
    "hard_skip_if_any_line_matches": [
      "^=+\([^)]*\)=+$",
      "^(WIFI|BT|CLIP)==>"
    ]
  },
  "configure": {
    // 파서 적용 후 유효라인 총합이 이 값 이하이면
    // 디스크 기반 T1 병합을 보수적으로 **스킵**하고 T0(메모리 모드)로 종료
    "memory_mode_threshold": 10000
  },
  "parser": [
    {
      "file": "system.log.{n}",
      "need": true,
      "regex": {
        "time": "^\[(?<time>(?:[A-Z][a-z]{2})\s+\d{1,2}\s+\d{2}:\d{2}:\d{2}(?:\.\d{3,6})?)\]",
        "process": "^\[[^\]]+\]\s+(?<process>[A-Za-z0-9._-]+)(?=\[|:)",
        "pid": "^\[[^\]]+\]\s+[A-Za-z0-9._-]+(?:\[(?<pid>\d+)\])?:",
        "message": "^\[[^\]]+\]\s+[A-Za-z0-9._-]+(?:\[\d+\])?:\s+(?<message>.+)$"
      }
    }
    // ... (다른 파일군 정의는 동일 규칙 적용)
  ]
}
```

### 키 설명

#### 1) `version`
스키마 진화를 위한 호환성 플래그입니다. **현재는 1만 지원**합니다.

#### 2) `requirements.fields` (프리플라이트 전용)
파일 단위 사전 검사에서 **매칭 비율 계산 시 필수로 간주**할 필드를 지정합니다.  
> **주의(시스템 변경점)**: 프리플라이트 판단과 별개로, **파서가 실제 적용된 파일**에서는
> `time/process/pid/message` 중 **time·process·pid가 모두 누락된 라인**을 **무효 라인으로 폐기**합니다.
> (헤더 전부 미검출 라인은 정렬 안정성과 품질을 위해 드롭)

#### 3) `preflight`
파일별 사전 검사 규칙입니다.
- `sample_lines`: 앞쪽 일부 라인을 읽어 샘플로 사용
- `min_match_ratio`: 필수 필드 충족 라인 비율이 미만이면 커스텀 파서 **미적용**
- `hard_skip_if_any_line_matches`: 하나라도 매칭되면 해당 파일은 커스텀 파서 **미적용**

**커스텀 파서 미적용** 시에는 기존 휴리스틱으로 병합합니다.
- **타임스탬프 추정**: `TimeParser.parseTs()`로 라인 전체에서 시간 패턴 탐색
- **레벨 추정**: `guessLevel()`로 ERROR/WARN/INFO/DEBUG 자동 판별
- **타입 분류**: system/homey/application/other 자동 분류
- **메시지**: 전체 라인을 메시지로 사용 (별도 파싱 없음)
> 이 경로에서는 **라인 드롭을 하지 않습니다.**

#### 4) `configure.memory_mode_threshold`  ✅ *신규*
- 병합 시작 전에 **파서를 적용해 무효 라인을 제거**한 뒤, **유효 라인 총합**을 계산합니다.
- 유효 합계가 `memory_mode_threshold` **이하**이면 **T1(디스크 기반 병합)을 스킵**하고, **T0(메모리 모드)** 로 종료합니다.
- 보수 규칙: **모든 타입/파일을 끝까지 스캔**하여 유효라인 총합을 계산합니다. (부분 샘플만으로 스킵하지 않음)
- 스킵 시 동작:
  - 파일 기반 pagination을 **열지 않습니다.**
  - 초기(T0)로 송신한 최신 윈도우만 유지하고 **진행률을 고정**합니다(`active:false`).

#### 5) `parser[]`
```jsonc
{
  "file": "system.log.{n | 0 | K | :K}",
  "need": true | false,
  "regex": {
    "time": "<REGEX>",
    "process": "<REGEX>",
    "pid": "<REGEX>",
    "message": "<REGEX>"
  }
}
```
- 여러 파일군을 정의하려면 위 블록을 배열로 나란히 나열합니다.

##### 파일 선택자 문법 (`{}` 내부)
- `n`  : **모든 로테이션** 포함 → `system.log`, `system.log.1`, `system.log.2`, …  
- `0`  : **베이스만** 포함 → `system.log`  
- `K`  : **정확히 해당 번호만** 포함 (`7` → `system.log.7`, `0`은 `system.log`와 동일)  
- `:K` : **최신부터 K까지 구간 포함** (`:2` → `system.log`, `system.log.1`, `system.log.2`)  
> 존재하지 않는 파일은 조용히 건너뜁니다. 검색은 **루트(비재귀)** 기준입니다.

---

## T0/T1 파이프라인과 보수적 스킵 로직

### 파이프라인 개요
1. **T0(Warmup)**: 최신→오래된 역방향 수집, **파서 적용 + 무효 라인 드롭**, 연도 없는 포맷 **롤오버 스티칭**, **단조 보정** 후 최신순(desc) 정렬, 최신 윈도우 전송.  
2. **유효 라인 총합 계산**: **모든 타입/파일**을 끝까지 스캔해 유효 라인만 누적.  
3. **임계 비교**: 유효 합계 `≤ configure.memory_mode_threshold` → **T1 스킵** (메모리 모드 유지).  
4. **T1(정식 병합)**: 위 조건을 넘으면 타입별 정렬 JSONL 생성 → k-way 병합 → 청크/매니페스트 저장 → 파일 기반 pagination 전환.

### 보수적 선택 이유
- **부분 샘플 기반 판단 금지**: tail 일부만 보고 스킵 결정하지 않습니다.  
- **정렬/동기화 안정**: 파서 적용 후 헤더 전부 미검출 라인은 드롭하여 **시간축/정렬 품질을 확보**합니다.  
- **UI 동기화 유지**: T1 스킵 시 **파일 기반 리더 미오픈**, 진행률을 **정확히 한 번** 고정하여 레이스를 차단합니다.

---

## FAQ

**Q. `.config/custom_log_parser.json`을 지웠습니다.**  
A. 명령 **“Parser 초기화”**로 템플릿을 재생성하세요. 확장을 다시 활성화해도 자동 시드됩니다.

**Q. `version` 필드는 왜 필요하죠?**  
A. 앞으로 스키마를 확장할 때 하위 호환/마이그레이션을 제어하기 위해 사용합니다.

**Q. 정규식이 너무 복잡합니다.**  
A. 템플릿을 그대로 사용해도 됩니다. 환경에 맞게 파일군과 정규식 일부만 유지해도 되며, 프리플라이트는 자동으로 적용/미적용을 판별합니다.

---

## 주요 변경점 요약(이 문서 기준)
- `configure.memory_mode_threshold` 신설 및 **T1 스킵 기준을 “유효 라인 총합”**으로 결정.  
- **파서 적용 파일에서 헤더 전부 미검출 라인은 드롭**(정렬/품질 보존 목적).  
- 스킵 시 **파일 기반 pagination 미오픈**, 진행률 **단일 고정**으로 동기화 안정성 강화.
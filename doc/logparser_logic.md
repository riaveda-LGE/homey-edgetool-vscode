# 로그 파서 파일 선택 규칙 사양 (간략 버전)

본 문서는 로테이션 로그 파일에 대한 **명시적 파일 선택 규칙**과 **정규식 파서 스키마**를 정의합니다. 기존의 복잡한 파일명 정규식 추론을 제거하고, 선언적인 설정으로 견고하게 동작하는 것을 목표로 합니다.

---

## 1) 설정 스키마

```jsonc
{
  "file": "system.log.{n | 0 | K | :K}",
  "need": true,
  "regex": {
    "time":    "<REGEX>",
    "process": "<REGEX>",
    "pid":     "<REGEX>",
    "message": "<REGEX>"
  }
}
```
- 여러 파일군을 정의하려면 위 블록을 배열로 나란히 나열합니다.

### 필드 설명
- **file**: 로테이션 세트를 나타내는 패턴. `system.log.{...}` 처럼 **basename + .log + {선택자}** 형식.
- **need**: 이 항목을 **파싱에 포함(true)** / **완전히 무시(false)**.
- **regex**: 각 라인의 `time / process / pid / message`를 추출하는 정규식. 기존 규칙과 동일.

---

## 2) 파일 선택자 문법 (`{}` 내부)

`{}`에는 아래 중 하나가 올 수 있습니다.

- `n` : **모든 로테이션 파일 포함**
  - 예: `system.log`, `system.log.1`, `system.log.2`, …
- `0` : **베이스 파일만 포함**
  - 예: `system.log`
- `K` (정수): **정확히 해당 로테이션 번호만 포함**
  - 예: `7` → `system.log.7` (K>0), `0`은 `system.log`와 동일
- `:K` : **최신부터 K까지 구간 포함(포함 범위)**
  - 예: `:2` → `system.log`, `system.log.1`, `system.log.2`

> ⚠️ 존재하지 않는 파일은 **조용히 건너뜁니다**(누락 허용). 검색은 **루트(비재귀)** 기준으로 수행합니다.

---

## 3) 동작 흐름 (요약)

1. 설정에 선언된 항목들을 순회
2. `need:false`인 항목은 **스킵**
3. `file` 선택자에 따라 **포함할 파일 목록 계산**
4. **존재하는 파일만** 읽어 각 라인에 `regex` 적용으로 필드 추출
5. 이후 병합/정렬/표시는 기존 파이프라인에 그대로 연결

---

## 4) 예시

### 4.1 모든 로테이션 포함
```json
{
  "file": "system.log.{n}",
  "need": true,
  "regex": {
    "time": "^\\[(?<time>(?:[A-Z][a-z]{2})\\s+\\d{1,2}\\s+\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3,6})?)\\]",
    "process": "^\\[[^\\]]+\\]\\s+(?<process>[A-Za-z0-9._-]+)(?=\\[|:)",
    "pid": "^\\[[^\\]]+\\]\\s+[A-Za-z0-9._-]+(?:\\[(?<pid>\\d+)\\])?:",
    "message": "^\\[[^\\]]+\\]\\s+[A-Za-z0-9._-]+(?:\\[\\d+\\])?:\\s+(?<message>.+)$"
  }
}
```

### 4.2 최신부터 `.2`까지
```json
{ "file": "system.log.{:2}", "need": true, "regex": { /* 동일 */ } }
```

### 4.3 베이스 파일만
```json
{ "file": "system.log.{0}", "need": true, "regex": { /* 동일 */ } }
```

### 4.4 특정 로테이션만
```json
{ "file": "system.log.{7}", "need": true, "regex": { /* 동일 */ } }
```

### 4.5 참여 제외(무시)
```json
{ "file": "noisy.log.{n}", "need": false, "regex": { /* 임의 */ } }
```

---

## 5) 구현 메모 (가이드)

- 선택자 파싱 → 파일 목록 생성 → `fs.exists` 체크 → 파싱 순으로 단순 파이프라인 구성
- 로테이션 정렬 기준: `.log`(최신) → `.log.1` → `.log.2` … (작은 번호가 더 최신)
- `{n}`은 **존재하는 모든 로테이션**을 포함하도록 동적 탐색
- 드롭된 파일(미존재)은 **로그 경고 없이 건너뜀**으로 노이즈 최소화
- `regex`는 캡처 그룹 이름(`time`, `process`, `pid`, `message`)을 사용

---

## 6) 빠른 체크리스트

- [ ] 필요 파일군만 `need:true`
- [ ] 선택자(`n` / `0` / `K` / `:K`)로 **명시적 포함 범위** 지정
- [ ] 정규식은 **헤더 기준**으로 안정적으로 캡처
- [ ] 존재하지 않는 파일은 자동 스킵

---

## 부록) 예시 정규식 설명 (syslog 류)

- `time` : `[Mon DD HH:MM:SS(.sss)]` 패턴
- `process` : `proc` 혹은 `proc[pid]` 형태의 프로세스명
- `pid` : `[...]` 내부 숫자 추출 (없으면 비어 있음)
- `message` : `proc(:|[pid]:)` 다음 전체 메시지

필요 시 파일군별로 각기 다른 `regex`를 지정할 수 있습니다.
